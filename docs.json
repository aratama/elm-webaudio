[{"name":"WebAudio","comment":" elm-webaudio provides methods to play audio in Elm.\n\n\n# Basic Types\n\n@docs Url\n\n@docs Time\n\n@docs Float32Array\n\n\n# Audio Graph\n\n@docs Graph\n\n@docs Node\n\n@docs Props\n\n@docs NodeId\n\n@docs Output\n\n@docs Param\n\n@docs Method\n\n@docs DynamicsCompressorProps\n\n@docs Oversample\n\n@docs OscillatorType\n\n@docs Destination\n\n\n# Rendering\n\n@docs toHtml\n\n\n# Utilities\n\n@docs output\n\n@docs dynamicsCompressor\n\n@docs dynamicsCompressorDefaults\n\n@docs parallel\n\n@docs serial\n\n","unions":[{"name":"Destination","comment":" Propertiy name as a audio output destination.\n","args":[],"cases":[["FrequencyProp",[]],["DetuneProp",[]],["GainProp",[]],["DelayTimeProp",[]],["PanProp",[]]]},{"name":"Method","comment":" Methods for AudioParam.\n","args":[],"cases":[["SetValueAtTime",["Basics.Float","WebAudio.Time"]],["LinearRampToValueAtTime",["Basics.Float","WebAudio.Time"]],["ExponentialRampToValueAtTime",["Basics.Float","WebAudio.Time"]],["SetTargetAtTime",["Basics.Float","WebAudio.Time","Basics.Float"]],["SetValueCurveAtTime",["List.List Basics.Float","WebAudio.Time","Basics.Float"]]]},{"name":"NodeId","comment":" Unique identifier of audio nodes in the audio graph.\n","args":[],"cases":[["NodeId",["String.String"]]]},{"name":"OscillatorType","comment":" ","args":[],"cases":[["Sine",[]],["Square",[]],["Sawtooth",[]],["Triangle",[]],["Custom",[]]]},{"name":"Output","comment":" Audio output.\n","args":[],"cases":[["Output",["WebAudio.NodeId"]],["Outputs",["List.List WebAudio.NodeId"]],["OutputToProp",["{ key : WebAudio.NodeId, destination : WebAudio.Destination }"]]]},{"name":"Oversample","comment":" ","args":[],"cases":[["OversampleNone",[]],["Oversample2x",[]],["Oversample4x",[]]]},{"name":"Param","comment":" AudioParam.\n","args":[],"cases":[["Constant",["Basics.Float"]],["Methods",["List.List WebAudio.Method"]]]},{"name":"Props","comment":" ","args":[],"cases":[["Analyser",["{ fftSize : Basics.Int, minDecibels : Basics.Float, maxDecibels : Basics.Float, smoothingTimeConstant : Basics.Float }"]],["BufferSource",["{ buffer : WebAudio.Url, startTime : WebAudio.Time, stopTime : Maybe.Maybe WebAudio.Time, detune : Basics.Int }"]],["BiquadFilter",["{ type_ : WebAudio.BiquadFilterType, frequency : WebAudio.Param, detune : WebAudio.Param, q : WebAudio.Param }"]],["ChannelMerger",[]],["ChannelSplitter",[]],["Convolver",["{ buffer : WebAudio.Url, normalize : Basics.Bool }"]],["Delay",["{ delayTime : WebAudio.Param, maxDelayTime : WebAudio.Param }"]],["DynamicsCompressor",["WebAudio.DynamicsCompressorProps"]],["Gain",["{ gain : WebAudio.Param }"]],["MediaElementSource",["{ mediaElement : WebAudio.MediaElementId }"]],["MediaStreamDestination",[]],["Oscillator",["{ type_ : WebAudio.OscillatorType, frequency : WebAudio.Param, startTime : WebAudio.Time, stopTime : WebAudio.Time }"]],["Panner",["{ coneInnerAngle : Basics.Float, coneOuterAngle : Basics.Float, coneOuterGain : Basics.Float, distanceModel : WebAudio.DistanceModel, orientationX : WebAudio.Param, orientationY : WebAudio.Param, orientationZ : WebAudio.Param, panningModel : WebAudio.PanningModel, positionX : WebAudio.Param, positionY : WebAudio.Param, positionZ : WebAudio.Param, maxDistance : Basics.Float, refDistance : Basics.Float, rolloffFactor : Basics.Float }"]],["StereoPanner",["{ pan : WebAudio.Param }"]],["WaveShaper",["{ curve : WebAudio.Float32Array, oversample : WebAudio.Oversample }"]]]},{"name":"Time","comment":" Float value representing audio time.\n","args":[],"cases":[["Time",["Basics.Float"]]]},{"name":"Url","comment":" URL for an audio buffer.\n\nElm can't deal `AudioBuffer` objects directly\nand use URL instead of `AudioBuffer`.\n\n","args":[],"cases":[["Url",["String.String"]]]}],"aliases":[{"name":"DynamicsCompressorProps","comment":" Properties of DynamicsCompresor.\n","args":[],"type":"{ attack : WebAudio.Param, knee : WebAudio.Param, ratio : WebAudio.Param, release : WebAudio.Param, threshold : WebAudio.Param }"},{"name":"Float32Array","comment":" ","args":[],"type":"List.List Basics.Float"},{"name":"Graph","comment":" Audio graph.\n","args":[],"type":"List.List WebAudio.Node"},{"name":"Node","comment":" Audio node.\n","args":[],"type":"{ id : WebAudio.NodeId, output : WebAudio.Output, props : WebAudio.Props }"}],"values":[{"name":"dynamicsCompressor","comment":" Utility constructor for a DynaicCompressor.\n","type":"(WebAudio.DynamicsCompressorProps -> WebAudio.DynamicsCompressorProps) -> WebAudio.Props"},{"name":"dynamicsCompressorDefaults","comment":" ","type":"WebAudio.DynamicsCompressorProps"},{"name":"output","comment":" Special identifier representing final destination. This is just a `Output (NodeId \"output\")`.\n","type":"WebAudio.Output"},{"name":"parallel","comment":" Name nodes automatically and connect in parallel.\n\n    parallel (NodeId \"x\") output x [ a, b, c ]\n\nis converted into a audio graph as:WW\n\n```js\n[ { id = \"x\", output = \"output\", props = x }\n, { id = \"x/0\", output = \"x\", props = a }\n, { id = \"x/1\", output = \"x\", props = b }\n, { id = \"x/2\", output = \"x\", props = c }\n]\n```\n\n","type":"WebAudio.NodeId -> WebAudio.Output -> WebAudio.Props -> List.List WebAudio.Props -> List.List WebAudio.Node"},{"name":"serial","comment":" Name nodes automatically and connect them serially.\n\n    serial (NodeId \"x\") output x [ a, b, c ]\n\nis converted into a audio grapha as:\n\n```js\n[ { id = \"x\", output = \"output\", props = x }\n, { id = \"x/0\", output = \"x\", props = a }\n, { id = \"x/0/0\", output = \"x/0\", props = b }\n, { id = \"x/0/0/0\", output = \"x/0/0\", props = c }\n]\n```\n\n","type":"WebAudio.NodeId -> WebAudio.Output -> List.List WebAudio.Props -> List.List WebAudio.Node"},{"name":"toHtml","comment":" Render an audio graph as HTML.\n\nNOTE: Each audio nodes should have unique id. If two nodes have the same id, the second node overwrites the first node.\n\n","type":"{ graph : WebAudio.Graph, assets : List.List WebAudio.Url, onTick : WebAudio.Time -> msg, onProgress : List.List WebAudio.Url -> msg } -> Html.Html msg"}],"binops":[]}]